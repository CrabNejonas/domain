//! Support for TSIG.

use std::cmp;
use bytes::{BigEndian, ByteOrder, Bytes};
use ring::{constant_time, digest, hmac};
use crate::bits::name::{Dname, Label, ToDname, ToLabelIter};
use crate::bits::record::Record;
use crate::iana::{Class, TsigRcode};
use crate::rdata::rfc2845::{Time48, Tsig};


//------------ Key -----------------------------------------------------------

/// A key for use with TSIG.
///
/// A value of this type contains both the actual key, the signing algorithm,
/// and the name of the key.
pub struct Key {
    /// The key itself.
    ///
    /// The key also contains the algorithm.
    key: hmac::SigningKey,

    /// The name of the key as a domain name.
    name: Dname,

    /// Minimum length of a signature.
    ///
    /// This will be at least half the algorithm’s native signature length,
    /// at least 10, and at most the algorithm’s native signature length.
    /// Any function creating a value needs to make sure of that.
    min_sig_len: usize
}


impl Key {
    /// Creates a new key.
    pub fn new(
        algorithm: Algorithm,
        key: &[u8],
        name: Dname,
        truncate: Option<usize>,
    ) -> Self {
        let algorithm = algorithm.into_digest_algorithm();
        let min_sig_len = match truncate {
            Some(value) => {
                cmp::min(
                    cmp::max(
                        cmp::max(10, algorithm.output_len / 2),
                        value
                    ),
                    algorithm.output_len
                )
            },
            None => algorithm.output_len
        };
        Key {
            key: hmac::SigningKey::new(algorithm, key),
            name,
            min_sig_len,
        }
    }

    /// Returns the algorithm of this key.
    pub fn algorithm(&self) -> Algorithm {
        Algorithm::from_digest_algorithm(self.key.digest_algorithm())
    }

    /// Returns a reference to the name of this key.
    pub fn name(&self) -> &Dname {
        &self.name
    }

    /// Returns the minimum acceptable length of a signature.
    pub fn min_sig_len(&self) -> usize {
        self.min_sig_len
    }
}

/// # Low-level Signing and Verification
///
/// These methods generate and verify the various signatures required by the
/// TSIG protocol.
impl Key {
    /// Sign a request.
    ///
    /// Generates the signature for a request generated by a client. This is
    /// also used for signing answers if the time doesn’t check out.
    pub fn sign_request(
        &self,
        msg: &[u8],
        vars: &Variables
    ) -> hmac::Signature {
        let mut ctx = hmac::SigningContext::with_key(&self.key);
        ctx.update(msg);
        vars.sign(&mut ctx);
        ctx.sign()
    }

    /// Sign an answer.
    pub fn sign_answer(
        &self,
        request_mac: &hmac::Signature,
        msg: &[u8],
        vars: &Variables
    ) -> hmac::Signature {
        let mut ctx = hmac::SigningContext::with_key(&self.key);
        ctx.update(request_mac.as_ref());
        ctx.update(msg);
        vars.sign(&mut ctx);
        ctx.sign()
    }

    /// Checks the signature of a request.
    pub fn check_request(
        &self,
        msg: &[u8],
        vars: &Variables,
        mac: &hmac::Signature
    ) -> Result<(), ValidationError> {
        self.compare_signatures(&self.sign_request(msg, vars), mac)
    }

    /// Checks the singatures of an answer.
    pub fn check_answer(
        &self,
        request_mac: &hmac::Signature,
        msg: &[u8],
        vars: &Variables,
        mac: &hmac::Signature
    ) -> Result<(), ValidationError> {
        self.compare_signatures(&self.sign_answer(request_mac, msg, vars), mac)
    }

    /// Compares two signatures.
    ///
    /// The first signature is the expected value, the second the provided
    /// one. This considers signature truncation limited to whatever is
    /// acceptable by this key.
    fn compare_signatures(
        &self,
        expected: &hmac::Signature,
        provided: &hmac::Signature
    ) -> Result<(), ValidationError> {
        if provided.as_ref().len() < self.min_sig_len {
            return Err(ValidationError::ShortSig)
        }
        let expected = if provided.as_ref().len() < expected.as_ref().len() {
            &expected.as_ref()[..provided.as_ref().len()]
        }
        else {
            expected.as_ref()
        };
        constant_time::verify_slices_are_equal(expected, provided.as_ref())
            .map_err(|_| ValidationError::BadSig)
    }
}


//------------ Sequence ------------------------------------------------------

/// A sequence of messages to be signed.
pub struct Sequence {
    ctx: hmac::SigningContext,
}

impl Sequence {
    pub fn new(key: &Key, prior: Option<&hmac::Signature>) -> Self {
        let mut ctx = hmac::SigningContext::with_key(&key.key);
        if let Some(mac) = prior {
            ctx.update(mac.as_ref())
        }
        Sequence { ctx }
    }

    pub fn add_msg(&mut self, msg: &[u8]) {
        self.ctx.update(msg)
    }

    pub fn sign(mut self, vars: &Variables) -> hmac::Signature {
        vars.sign(&mut self.ctx);
        self.ctx.sign()
    }
}


//------------ Client --------------------------------------------------------

/// A client using TSIG.
///
//  signs a message, verifies its response.
#[derive(Clone, Debug)]
pub struct Client;


//------------ Variables -----------------------------------------------------

/// The TSIG Variables.
///
/// All parts of the future TSIG record that are not the actual MAC are used
/// as input for MAC generation. This type keeps those that are indeed
/// variable.
#[derive(Clone, Debug)]
pub struct Variables {
    name: Dname,
    algorithm: Algorithm,
    time_signed: Time48,
    fudge: u16,
    error: TsigRcode,
    other: Option<Time48>,
}

impl Variables {
    pub fn new(
        name: Dname, algorithm: Algorithm, time_signed: Time48, fudge: u16,
        error: TsigRcode, other: Option<Time48>
    ) -> Self {
        Variables {
            name, algorithm, time_signed, fudge, error, other
        }
    }

    pub fn from_tsig<NR: ToDname, NT: ToDname>(
        record: &Record<NR, Tsig<NT>>
    ) -> Result<Self, ValidationError> {
        let other = if record.data().other().is_empty() {
            None
        } else if let Some(other) = record.data().other_time() {
            Some(other)
        }
        else {
            return Err(ValidationError::BadOther)
        };
        Ok(Variables::new(
            record.owner().to_name(),
            Algorithm::from_dname(record.data().algorithm())
                .ok_or_else(|| {
                    ValidationError::BadAlg(
                        record.data().algorithm().to_name()
                    )
                })?,
            record.data().time_signed(),
            record.data().fudge(),
            record.data().error(),
            other
        ))
    }

    pub fn to_tsig(
        &self,
        hmac: &hmac::Signature,
        original_id: u16
    ) -> Record<Dname, Tsig<Dname>> {
        let other = match self.other {
            Some(time) => time.into_bytes(),
            None => Bytes::new()
        };
        Record::new(
            self.name.clone(),
            Class::Any,
            0,
            Tsig::new(
                self.algorithm.to_dname(),
                self.time_signed,
                self.fudge,
                Bytes::from(hmac.as_ref()),
                original_id,
                self.error,
                other,
            )
        )
    }

    pub fn sign(&self, context: &mut hmac::SigningContext) {
        let mut buf = [0u8; 8];

        // Key name, in canonical wire format
        for label in self.name.iter_labels().map(Label::to_canonical) {
            context.update(label.as_wire_slice());
        }
        // CLASS (Always ANY in the current specification)
        BigEndian::write_u16(&mut buf, Class::Any.to_int());
        context.update(&buf[..2]);
        // TTL (Always 0 in the current specification)
        BigEndian::write_u32(&mut buf, 0);
        context.update(&buf[..4]);
        // Algorithm Name (in canonical wire format)
        context.update(self.algorithm.into_wire_slice());
        // Time Signed
        BigEndian::write_u64(&mut buf, self.time_signed.into());
        context.update(&buf[2..]);
        // Fudge
        BigEndian::write_u16(&mut buf, self.fudge);
        context.update(&buf[..2]);
        // Error
        BigEndian::write_u16(&mut buf, self.error.to_int());
        context.update(&buf[..2]);
        // Other Len
        BigEndian::write_u16(
            &mut buf,
            if self.other.is_some() { 6 }
            else { 0 }
        );
        context.update(&buf[..2]);
        // Other
        if let Some(time) = self.other {
            BigEndian::write_u64(&mut buf, time.into());
            context.update(&buf[2..]);
        }
    }
}


//------------ Algorithm -----------------------------------------------------

/// The supported TSIG algorithms.
#[derive(Clone, Copy, Debug)]
pub enum Algorithm {
    Sha1,
    Sha256,
    Sha384,
    Sha512
}

impl Algorithm {
    /// Creates a value from its domain name representation.
    ///
    /// Returns `None` if the name doesn’t represent a known algorithm.
    pub fn from_dname<N: ToDname>(name: &N) -> Option<Self> {
        let mut labels = name.iter_labels();
        let first = match labels.next() {
            Some(label) => label,
            None => return None
        };
        match labels.next() {
            Some(label) if label.is_root() => {},
            _ => return None
        }
        match first.as_slice() {
            b"hmac-sha1" => Some(Algorithm::Sha1),
            b"hmac-sha256" => Some(Algorithm::Sha256),
            b"hmac-sha384" => Some(Algorithm::Sha384),
            b"hmac-sha512" => Some(Algorithm::Sha512),
            _ => None
        }
    }

    /// Creates a value from a digest algorithm.
    ///
    /// This will panic if `alg` is not one of the recognized algorithms.
    fn from_digest_algorithm(alg: &'static digest::Algorithm) -> Self {
        if *alg == digest::SHA1 {
            Algorithm::Sha1
        }
        else if *alg == digest::SHA256 {
            Algorithm::Sha256
        }
        else if *alg == digest::SHA384 {
            Algorithm::Sha256
        }
        else if *alg == digest::SHA512 {
            Algorithm::Sha512
        }
        else {
            panic!("Unknown TSIG key algorithm.")
        }
    }

    /// Returns the ring digest algorithm for this TSIG algorithm.
    pub fn into_digest_algorithm(self) -> &'static digest::Algorithm {
        match self {
            Algorithm::Sha1 => &digest::SHA1,
            Algorithm::Sha256 => &digest::SHA256,
            Algorithm::Sha384 => &digest::SHA384,
            Algorithm::Sha512 => &digest::SHA512,
        }
    }

    /// Returns a octet slice with the wire-format domain name for this value.
    pub fn into_wire_slice(self) -> &'static [u8] {
        match self {
            Algorithm::Sha1 => b"\x09hmac-sha1\0",
            Algorithm::Sha256 => b"\x0Bhmac-sha256\0",
            Algorithm::Sha384 => b"\x0Bhmac-sha384\0",
            Algorithm::Sha512 => b"\x0Bhmac-sha512\0",
        }
    }

    /// Returns a domain name for this value.
    pub fn to_dname(self) -> Dname {
        unsafe {
            Dname::from_bytes_unchecked(
                Bytes::from_static(self.into_wire_slice())
            )
        }
    }
}


//------------ ValidationError -----------------------------------------------

#[derive(Clone, Debug, Fail)]
pub enum ValidationError {
    #[fail(display="unknown algorithm '{}'", _0)]
    BadAlg(Dname),

    #[fail(display="bad content of other")]
    BadOther,

    #[fail(display="bad signatures")]
    BadSig,

    #[fail(display="short signature")]
    ShortSig,
}

